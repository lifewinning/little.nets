<!DOCTYPE HTML>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=US-ASCII">
<title>The Temple Operating System</title>
<meta name="keywords" content="Operating System,64-Bit,64 Bit,Temple,OS,TempleOS,Free,Open Source,Public Domain,x86_64">
<meta name="generator" content="TempleOS V2.08">
<style type="text/css">
.cF0{color:#000000;background-color:#fcfcfc;}
.cF1{color:#0000a8;background-color:#fcfcfc;}
.cF2{color:#00a800;background-color:#fcfcfc;}
.cF3{color:#00a8a8;background-color:#fcfcfc;}
.cF4{color:#a80000;background-color:#fcfcfc;}
.cF5{color:#a800a8;background-color:#fcfcfc;}
.cF6{color:#a85400;background-color:#fcfcfc;}
.cF7{color:#a8a8a8;background-color:#fcfcfc;}
.cF8{color:#545454;background-color:#fcfcfc;}
.cF9{color:#5454fc;background-color:#fcfcfc;}
.cFA{color:#54fc54;background-color:#fcfcfc;}
.cFB{color:#54fcfc;background-color:#fcfcfc;}
.cFC{color:#fc5454;background-color:#fcfcfc;}
.cFD{color:#fc54fc;background-color:#fcfcfc;}
.cFE{color:#fcfc54;background-color:#fcfcfc;}
.cFF{color:#fcfcfc;background-color:#fcfcfc;}
</style>
</head>
<body>
<pre style="font-family:courier;font-size:10pt">
<a name="l1"></a><span class=cF5>                                     HolyC</span><span class=cF0>
<a name="l2"></a>
<a name="l3"></a>* See </span><a href="ImportExports.html#l1"><span class=cF4>Scoping and Linkages</span></a><span class=cF0> for details on </span><span class=cF2>extern</span><span class=cF0>, </span><span class=cF2>import</span><span class=cF0>, </span><span class=cF2>_extern</span><span class=cF0>, </span><span class=cF2>_import</span><span class=cF0>, etc.
<a name="l4"></a>
<a name="l5"></a>* See </span><a href="CompilerOverview.html#l1"><span class=cF4>::/Doc/CompilerOverview.TXT</span></a><span class=cF0>.
<a name="l6"></a>
<a name="l7"></a>* Built-in types include </span><span class=cF2>I0,I8,I16,I32,I64</span><span class=cF0> for signed 0-8 byte ints and </span><span class=cF2>U0,U8,U1
<a name="l8"></a>6,U32,U64</span><span class=cF0> for unsigned 0-8 byte ints and </span><span class=cF2>F64</span><span class=cF0> for 8 byte floats.
<a name="l9"></a>
<a name="l10"></a></span><span class=cF2>        U0      void, but ZERO size!
<a name="l11"></a>        I8      char
<a name="l12"></a>        U8      unsigned char
<a name="l13"></a>        I16     short
<a name="l14"></a>        U16     unsigned short
<a name="l15"></a>        I32     int
<a name="l16"></a>        U32     unsigned int
<a name="l17"></a>        I64     long (64-bit)
<a name="l18"></a>        I64     unsigned long (64-bit)
<a name="l19"></a>        F64     double</span><span class=cF0>
<a name="l20"></a>        </span><span class=cF4>no F32 float.</span><span class=cF0>
<a name="l21"></a>
<a name="l22"></a>* Function with no args, or just default args can be called without parentheses. 
<a name="l23"></a>
<a name="l24"></a>  &gt;</span><span class=cF2>Dir(&quot;*&quot;);</span><span class=cF0>
<a name="l25"></a>  &gt;</span><span class=cF2>Dir();</span><span class=cF0>
<a name="l26"></a>  &gt;</span><span class=cF2>Dir;</span><span class=cF0>
<a name="l27"></a>
<a name="l28"></a>* Default args don't have to be on the end.  This code is valid:
<a name="l29"></a>  </span><span class=cF2>U0 Test(I64 i=4,I64 j,I64 k=5)
<a name="l30"></a>  {
<a name="l31"></a>    Print(&quot;%X %X %X\n&quot;,i,j,k);
<a name="l32"></a>  }
<a name="l33"></a>  
<a name="l34"></a>  Test(,3);</span><span class=cF0>
<a name="l35"></a>
<a name="l36"></a>* A char const all alone is sent to </span><a href="../Kernel/KeyDev.html#l20"><span class=cF4>PutChars</span></a><span class=cF0>().  A string with or without args 
<a name="l37"></a>is sent to </span><a href="../Kernel/StrPrint.html#l949"><span class=cF4>Print</span></a><span class=cF0>().  An empty string literal signals a variable fmt_str follows.
<a name="l38"></a>
<a name="l39"></a>  </span><span class=cF2>void DemoC(char drv,char *fmt,char *name,int age)
<a name="l40"></a>  {
<a name="l41"></a>    printf(&quot;Hello World!\n&quot;);
<a name="l42"></a>    printf(&quot;%s age %d\n&quot;,name,age);
<a name="l43"></a>    printf(fmt,name,age);
<a name="l44"></a>    putchar(drv);
<a name="l45"></a>    putchar('*');
<a name="l46"></a>  }
<a name="l47"></a>  
<a name="l48"></a>  U0 DemoHolyC(U8 drv,U8 *fmt,U8 *name,I64 age)
<a name="l49"></a>  {
<a name="l50"></a>    &quot;Hello World!\n&quot;;
<a name="l51"></a>    &quot;%s age %d\n&quot;,name,age;
<a name="l52"></a>    &quot;&quot; fmt,name,age;
<a name="l53"></a>    '' drv;
<a name="l54"></a>    '*';
<a name="l55"></a>  }
<a name="l56"></a></span><span class=cF0>
<a name="l57"></a>* When dealing with function addresses such as for callbacks, precede the name 
<a name="l58"></a>with &quot;</span><span class=cF2>&amp;</span><span class=cF0>&quot;.
<a name="l59"></a>
<a name="l60"></a>* Type casting is postfix.  To typecast int or F64, use </span><a href="../Kernel/Adam1b.html#l110"><span class=cF4>ToI64</span></a><span class=cF0>(), </span><a href="../Kernel/Adam1b.html#l108"><span class=cF4>ToBool</span></a><span class=cF0>() or </span><span class=cF4>
<a name="l61"></a></span><a href="../Kernel/Adam1b.html#l109"><span class=cF4>ToF64</span></a><span class=cF0>(). (TempleOS follows normal C float&lt;--&gt;int conversion, but sometimes you 
<a name="l62"></a>want to override.  These functions are better than multiplying by &quot;1.0&quot; to 
<a name="l63"></a>convert to float.) 
<a name="l64"></a>
<a name="l65"></a>* There is no </span><span class=cF2>main()</span><span class=cF0> function.  Any code outside of functions gets executed upon 
<a name="l66"></a>start-up, in order.
<a name="l67"></a>
<a name="l68"></a>* There are no bit fields, but there are </span><span class=cF4>bit access</span><span class=cF0> routines and you can access 
<a name="l69"></a>bytes or words within any int.  See </span><a href="../Kernel/Adam1a.html#l101"><span class=cF4>I64 declaration</span></a><span class=cF0>.  A class can be accessed as 
<a name="l70"></a>a whole are subints, if you put a type in front of the </span><span class=cF2>class</span><span class=cF0> declaration.
<a name="l71"></a>  
<a name="l72"></a>  </span><span class=cF2>public I64i union I64         //&quot;I64i&quot; is intrinsic.  We are defining &quot;I64&quot;.
<a name="l73"></a>  {
<a name="l74"></a>    I8i i8[8];
<a name="l75"></a>    U8i u8[8];
<a name="l76"></a>    I16 i16[4];
<a name="l77"></a>    U16 u16[4];
<a name="l78"></a>    I32 i32[2];
<a name="l79"></a>    U32 u32[2];
<a name="l80"></a>  };
<a name="l81"></a>  
<a name="l82"></a>  I64 i=0x123456780000DEF0;
<a name="l83"></a>  i.u16[1]=0x9ABC;
<a name="l84"></a></span><span class=cF0>
<a name="l85"></a>* Variable arg count functions (</span><span class=cF2>...</span><span class=cF0>) can access their args with built-in 
<a name="l86"></a>variables similar to '</span><span class=cF2>this</span><span class=cF0>' in C++.  They are '</span><span class=cF2>I64 argc</span><span class=cF0>' and '</span><span class=cF2>I64 argv[]</span><span class=cF0>'.  
<a name="l87"></a>  
<a name="l88"></a>  </span><span class=cF2>I64 AddNums(...)
<a name="l89"></a>  {
<a name="l90"></a>    I64 i,result=0;
<a name="l91"></a>    for (i=0;i&lt;argc;i++)
<a name="l92"></a>      result+=argv[i];
<a name="l93"></a>    return result;
<a name="l94"></a>  }
<a name="l95"></a>  
<a name="l96"></a>  </span><span class=cF0>&gt;</span><span class=cF2>AddNums(1,2,3);</span><span class=cF0>
<a name="l97"></a>  ans=6
<a name="l98"></a>  </span><span class=cF2>
<a name="l99"></a>  
<a name="l100"></a>  public U0 GrPrint(CDC *dc,I64 x,I64 y,U8 *fmt,...)
<a name="l101"></a>  {
<a name="l102"></a>    U8 *buf=</span><a href="../Kernel/StrPrint.html#l247"><span class=cF4>StrPrintJoin</span></a><span class=cF2>(NULL,fmt,argc,argv);//SPrintF() with </span><a href="../Kernel/Mem1b.html#l375"><span class=cF4>MAlloc</span></a><span class=cF2>()ed string.
<a name="l103"></a>    </span><a href="../Adam/Gr/GrBitMap.html#l823"><span class=cF4>GrPutS</span></a><span class=cF2>(dc,x,y,buf); //Plot string at x,y pixels. GrPutS is not public.
<a name="l104"></a>    Free(buf);
<a name="l105"></a>  }
<a name="l106"></a>  
<a name="l107"></a>    ...
<a name="l108"></a>  
<a name="l109"></a>    GrPrint(gr.dc,(GR_WIDTH-10*FONT_WIDTH)&gt;&gt;1,(GR_HEIGHT-FONT_HEIGHT)&gt;&gt;1,
<a name="l110"></a>        &quot;Score:%4d&quot;,score);  //Print score in the center of the screen.
<a name="l111"></a>    ...
<a name="l112"></a>  
<a name="l113"></a></span><span class=cF0>
<a name="l114"></a>* Allows &quot;</span><span class=cF2>5&lt;i&lt;j+1&lt;20</span><span class=cF0>&quot; instead of &quot;</span><span class=cF2>5&lt;i &amp;&amp; i&lt;j+1 &amp;&amp; j+1&lt;20</span><span class=cF0>&quot;.
<a name="l115"></a>  
<a name="l116"></a>  </span><span class=cF2>if (13&lt;=age&lt;20)
<a name="l117"></a>    &quot;Teen-ager&quot;;
<a name="l118"></a></span><span class=cF0>
<a name="l119"></a>* </span><span class=cF2>switch</span><span class=cF0> statements always use a jump table.  Don't use them with cases with 
<a name="l120"></a>really big, sparse ranges.
<a name="l121"></a>
<a name="l122"></a>* Allows ranges like &quot;</span><span class=cF2>case 4...7:</span><span class=cF0>&quot; in </span><span class=cF2>switch</span><span class=cF0> statements. 
<a name="l123"></a>
<a name="l124"></a>* </span><span class=cF2>nobound_switch</span><span class=cF0> can be used if you know a switch statement will not exceed the 
<a name="l125"></a>lowest or highest case values.  It's a little faster because it doesn't check.
<a name="l126"></a>
<a name="l127"></a>* </span><span class=cF2>sub_switch_start</span><span class=cF0>/</span><span class=cF2>sub_switch_end</span><span class=cF0> allow a new type of nested-switch control 
<a name="l128"></a>flow.  (Don't goto, throw exception or return out of </span><span class=cF2>sub_switch_start</span><span class=cF0> front 
<a name="l129"></a>porch area.)
<a name="l130"></a>
<a name="l131"></a>  </span><span class=cF2>U0 SubSwitch()
<a name="l132"></a>  {
<a name="l133"></a>    I64 i;
<a name="l134"></a>    for (i=0;i&lt;10;i++)
<a name="l135"></a>      switch (i) {
<a name="l136"></a>        case 0: &quot;Zero &quot;;        break;
<a name="l137"></a>        case 2: &quot;Two &quot;;         break;
<a name="l138"></a>        case 4: &quot;Four &quot;;        break;
<a name="l139"></a>        sub_switch_start:
<a name="l140"></a>          &quot;[&quot;;
<a name="l141"></a>          case 1: &quot;One&quot;;        break;
<a name="l142"></a>          case 3: &quot;Three&quot;;      break;
<a name="l143"></a>          case 5: &quot;Five&quot;;       break;
<a name="l144"></a>        sub_switch_end:
<a name="l145"></a>          &quot;] &quot;;
<a name="l146"></a>          break;
<a name="l147"></a>      }
<a name="l148"></a>    '\n';
<a name="l149"></a>  }</span><span class=cF0>
<a name="l150"></a>  OutPut:
<a name="l151"></a>  &gt;</span><span class=cF2>Zero [One] Two [Three] Four [Five]</span><span class=cF0>
<a name="l152"></a>
<a name="l153"></a>* A </span><span class=cF2>nounusedwarn</span><span class=cF0> statement will suppress an unused var warning.
<a name="l154"></a>
<a name="l155"></a>* You can have multiple member vars of a class named &quot;</span><span class=cF2>pad</span><span class=cF0>&quot; or &quot;</span><span class=cF2>reserved</span><span class=cF0>&quot;, and it 
<a name="l156"></a>won't issue warnings. 
<a name="l157"></a>
<a name="l158"></a>* </span><span class=cF2>noreg</span><span class=cF0> or </span><span class=cF2>reg</span><span class=cF0> can be placed before a function local var name.  You can, 
<a name="l159"></a>optionally, specify a reg after the </span><span class=cF2>reg</span><span class=cF0> keyword.
<a name="l160"></a>
<a name="l161"></a>  </span><span class=cF2>U0 Main()
<a name="l162"></a>  {
<a name="l163"></a>    //Only use </span><a href="../Kernel/Adam1a.html#l1694"><span class=cF4>REG_VARS_MASK</span></a><span class=cF2> or </span><a href="../Kernel/Adam1a.html#l1695"><span class=cF4>REG_NON_PTR_MASK</span></a><span class=cF2> for reg vars or else clobbered.
<a name="l164"></a>    I64 reg R15 i=5, noreg j=4;
<a name="l165"></a>    nounusedwarn i;
<a name="l166"></a>    asm {
<a name="l167"></a>        MOV     RAX,R15
<a name="l168"></a>        CALL    &amp;PUT_HEX_U64
<a name="l169"></a>        MOV     RAX,'\n'
<a name="l170"></a>        CALL    &amp;PUT_CHARS
<a name="l171"></a>        MOV     RAX,U64 &amp;j[RBP]
<a name="l172"></a>        CALL    &amp;PUT_HEX_U64
<a name="l173"></a>        MOV     RAX,'\n'
<a name="l174"></a>        CALL    &amp;PUT_CHARS
<a name="l175"></a>    }
<a name="l176"></a>  }
<a name="l177"></a></span><span class=cF0>
<a name="l178"></a>* </span><span class=cF2>interrupt</span><span class=cF0>, </span><span class=cF2>haserrcode</span><span class=cF0>, </span><span class=cF2>public</span><span class=cF0>, </span><span class=cF2>argpop</span><span class=cF0> or </span><span class=cF2>noargpop</span><span class=cF0> are function flags. See </span><span class=cF4>
<a name="l179"></a></span><a href="../Demo/Lectures/PageTableEntries2.html#l1"><span class=cF4>::/Demo/Lectures/PageTableEntries2.CPP</span></a><span class=cF0>.
<a name="l180"></a>
<a name="l181"></a>* A single quote can encompass multiple characters.  </span><span class=cF2>'ABC'</span><span class=cF0> is equal to </span><span class=cF2>0x434241</span><span class=cF0>. 
<a name="l182"></a> </span><a href="../Kernel/KeyDev.html#l20"><span class=cF4>PutChars</span></a><span class=cF0>() takes multiple characters.
<a name="l183"></a>
<a name="l184"></a>  </span><span class=cF2>asm {
<a name="l185"></a>  HELLO_WORLD::
<a name="l186"></a>        PUSH    RBP
<a name="l187"></a>        MOV     RBP,RSP
<a name="l188"></a>        MOV     RAX,'Hello '
<a name="l189"></a>        CALL    &amp;PUT_CHARS
<a name="l190"></a>        MOV     RAX,'World\n'
<a name="l191"></a>        CALL    &amp;PUT_CHARS
<a name="l192"></a>        LEAVE
<a name="l193"></a>        RET
<a name="l194"></a>  }
<a name="l195"></a>  Call(HELLO_WORLD);
<a name="l196"></a>  PutChars('Hello ');
<a name="l197"></a>  PutChars('World\n');
<a name="l198"></a></span><span class=cF0>
<a name="l199"></a>* The &quot;</span><span class=cF2>`</span><span class=cF0>&quot; operator raises a base to a power.
<a name="l200"></a>
<a name="l201"></a>* There is no question-colon operator.
<a name="l202"></a>
<a name="l203"></a>* TempleOS </span><a href="../Compiler/CmpInit.html#l530"><span class=cF4>operator precedence</span></a><span class=cF0>
<a name="l204"></a>  </span><span class=cF2>`</span><span class=cF0>,</span><span class=cF2>&gt;&gt;</span><span class=cF0>,</span><span class=cF2>&lt;&lt;</span><span class=cF0>
<a name="l205"></a>  </span><span class=cF2>*</span><span class=cF0>,</span><span class=cF2>/</span><span class=cF0>,</span><span class=cF2>%</span><span class=cF0>
<a name="l206"></a>  </span><span class=cF2>&amp;</span><span class=cF0>
<a name="l207"></a>  </span><span class=cF2>^</span><span class=cF0>
<a name="l208"></a>  </span><span class=cF2>|</span><span class=cF0>
<a name="l209"></a>  </span><span class=cF2>+</span><span class=cF0>,</span><span class=cF2>-</span><span class=cF0>
<a name="l210"></a>  </span><span class=cF2>&lt;</span><span class=cF0>,</span><span class=cF2>&gt;</span><span class=cF0>,</span><span class=cF2>&lt;=</span><span class=cF0>,</span><span class=cF2>&gt;=</span><span class=cF0>
<a name="l211"></a>  </span><span class=cF2>==</span><span class=cF0>,</span><span class=cF2>!=</span><span class=cF0>
<a name="l212"></a>  </span><span class=cF2>&amp;&amp;</span><span class=cF0>
<a name="l213"></a>  </span><span class=cF2>^^</span><span class=cF0>
<a name="l214"></a>  </span><span class=cF2>||</span><span class=cF0>
<a name="l215"></a>  </span><span class=cF2>=</span><span class=cF0>,</span><span class=cF2>&lt;&lt;=</span><span class=cF0>,</span><span class=cF2>&gt;&gt;=</span><span class=cF0>,</span><span class=cF2>*=</span><span class=cF0>,</span><span class=cF2>/=</span><span class=cF0>,</span><span class=cF2>&amp;=</span><span class=cF0>,</span><span class=cF2>|=</span><span class=cF0>,</span><span class=cF2>^=</span><span class=cF0>,</span><span class=cF2>+=</span><span class=cF0>,</span><span class=cF2>-=</span><span class=cF0>
<a name="l216"></a>
<a name="l217"></a>* You can use </span><a href="../Compiler/ICLCC.html#l5"><span class=cF4>OptOn</span></a><span class=cF0>(</span><a href="../Kernel/Adam1a.html#l1456"><span class=cF4>OPTf_WARN_PAREN</span></a><span class=cF0>) to find unnecessary parentheses in code.
<a name="l218"></a>
<a name="l219"></a>* You can use </span><a href="../Compiler/ICLCC.html#l5"><span class=cF4>OptOn</span></a><span class=cF0>(</span><a href="../Kernel/Adam1a.html#l1457"><span class=cF4>OPTf_WARN_DUP_TYPES</span></a><span class=cF0>) to find dup local var type statements.
<a name="l220"></a>
<a name="l221"></a>* With the </span><span class=cF2>#exe{}</span><span class=cF0> feature in your src code, you can place programs that insert 
<a name="l222"></a>text into the stream of code being compiled.  See </span><a href="../Kernel/KEnd.html#l17"><span class=cF4>#exe {}</span></a><span class=cF0> for an example where 
<a name="l223"></a>the date/time and compile-time prompting for cfguration data is placed into a 
<a name="l224"></a>program.  </span><a href="../Compiler/CmpMain.html#l1"><span class=cF4>StreamPrint</span></a><span class=cF0>() places text into a src program stream following the 
<a name="l225"></a>conclusion of the </span><span class=cF2>#exe{}</span><span class=cF0> blk.
<a name="l226"></a>
<a name="l227"></a>* No </span><span class=cF2>#define</span><span class=cF0> functions exist (I'm not a fan)
<a name="l228"></a>
<a name="l229"></a>* No </span><span class=cF2>typedef</span><span class=cF0>, use </span><span class=cF2>class</span><span class=cF0>.
<a name="l230"></a>
<a name="l231"></a>* No type-checking
<a name="l232"></a>
<a name="l233"></a>* Can't use </span><span class=cF2>&lt;&gt;</span><span class=cF0> with </span><span class=cF2>#include</span><span class=cF0>, use </span><span class=cF2>&quot;&quot;</span><span class=cF0>.
<a name="l234"></a>
<a name="l235"></a>* &quot;</span><span class=cF2>$</span><span class=cF0>&quot; is an escape character.  Two dollar signs signify an ordinary $.  See </span><span class=cF4>
<a name="l236"></a></span><a href="DolDocOverview.html#l1"><span class=cF4>DolDoc</span></a><span class=cF0>.  In </span><span class=cF2>asm</span><span class=cF0> or </span><a href="HolyC.html#l1"><span class=cF4>HolyC</span></a><span class=cF0> code, it also refers to the instruction's address or 
<a name="l237"></a>the offset in a </span><span class=cF2>class</span><span class=cF0> definition. 
<a name="l238"></a>
<a name="l239"></a>* </span><span class=cF2>union</span><span class=cF0> is more like a class, so you don't reference it with a </span><span class=cF2>union</span><span class=cF0> label after 
<a name="l240"></a>you define it.  Some common unions are declared in </span><a href="../Kernel/Adam1a.html#l63"><span class=cF4>Adam1a.HPP</span></a><span class=cF0> for 1,2,4 and 8 
<a name="l241"></a>byte objects.  If you place a type in front of a union declaration, that is the 
<a name="l242"></a>type when used by itself.  See </span><a href="../Demo/SubIntAccess.html#l1"><span class=cF4>::/Demo/SubIntAccess.CPP</span></a><span class=cF0>. 
<a name="l243"></a>
<a name="l244"></a>* </span><span class=cF2>class</span><span class=cF0> member vars can have meta data. </span><span class=cF2>fmtstr</span><span class=cF0> and </span><span class=cF2>fmtdata</span><span class=cF0> are two meta data 
<a name="l245"></a>types now used.  All compiler structures are saved and you can access the 
<a name="l246"></a>compiler's info about classes and vars.  See </span><a href="../Demo/ClassMeta.html#l1"><span class=cF4>::/Demo/ClassMeta.CPP</span></a><span class=cF0> and  </span><span class=cF4>
<a name="l247"></a></span><a href="../Adam/DolDoc/DocPopUp.html#l300"><span class=cF4>DocFormDo</span></a><span class=cF0>().
<a name="l248"></a>
<a name="l249"></a>* There is a keyword </span><span class=cF2>lastclass</span><span class=cF0> you use as a dft arg.  It is set to the class 
<a name="l250"></a>name of the previous arg.  See </span><a href="../Demo/LastClass.html#l1"><span class=cF4>::/Demo/LastClass.CPP</span></a><span class=cF0>, </span><a href="../Adam/Dbg2a.html#l152"><span class=cF4>ClassRep</span></a><span class=cF0>(), </span><a href="../Adam/DolDoc/DocPopUp.html#l300"><span class=cF4>DocFormDo</span></a><span class=cF0>()  
<a name="l251"></a>and </span><a href="../Demo/Dsk/BlkDevRep.html#l1"><span class=cF4>::/Demo/Dsk/BlkDevRep.CPP</span></a><span class=cF0>.
<a name="l252"></a>
<a name="l253"></a>* See </span><a href="../Demo/Exceptions.html#l1"><span class=cF4>::/Demo/Exceptions.CPP</span></a><span class=cF0>.  </span><span class=cF2>try{} catch{}</span><span class=cF0> and </span><span class=cF2>throw</span><span class=cF0> are different from C++. </span><span class=cF2>t
<a name="l254"></a>hrow</span><span class=cF0> is a function with an 8-byte or less char arg.  The char string passed in </span><span class=cF2>t
<a name="l255"></a>hrow()</span><span class=cF0> can be accessed from within a </span><span class=cF2>catch{}</span><span class=cF0> using the </span><span class=cF2>Fs-&gt;except_ch</span><span class=cF0>.  Within a </span><span class=cF2>
<a name="l256"></a>catch {}</span><span class=cF0> blk, set the var </span><span class=cF2>Fs-&gt;catch_except</span><span class=cF0> to </span><span class=cF2>TRUE</span><span class=cF0> if you want to terminate the 
<a name="l257"></a>search for a handler.  Use </span><a href="../Kernel/Except.html#l46"><span class=cF4>PutExcept</span></a><span class=cF0>() as a handler, if you like.
<a name="l258"></a>
<a name="l259"></a>* A function is available similar to </span><span class=cF2>sizeof</span><span class=cF0> which provides the offset of a 
<a name="l260"></a>member of a class.  It's called </span><span class=cF2>offset</span><span class=cF0>.  You place the class name and member 
<a name="l261"></a>inside as in </span><span class=cF2>offset(classname.membername)</span><span class=cF0>.  It has nothing to do with 16-bit 
<a name="l262"></a>code.  Both </span><span class=cF2>sizeof</span><span class=cF0> and </span><span class=cF2>offset</span><span class=cF0> only accept one level of member vars.  That is, 
<a name="l263"></a>you can't do </span><span class=cF2>sizeof(classname.membername.submembername)</span><span class=cF0>.
<a name="l264"></a>
<a name="l265"></a>* There is no </span><span class=cF2>continue</span><span class=cF0> statement.  Use </span><span class=cF2>goto</span><span class=cF0>.
<a name="l266"></a>
<a name="l267"></a>* </span><span class=cF2>lock{}</span><span class=cF0> can be used to apply asm </span><span class=cF2>LOCK</span><span class=cF0> prefixes to code for safe multicore 
<a name="l268"></a>read-modify-write accesses.  The code bracked with have </span><span class=cF2>LOCK</span><span class=cF0> asm prefix's 
<a name="l269"></a>applied to relevant instructions within.  It's a little shoddy.  See </span><span class=cF4>
<a name="l270"></a></span><a href="../Demo/MultiCore/Lock.html#l1"><span class=cF4>::/Demo/MultiCore/Lock.CPP</span></a><span class=cF0>.
<a name="l271"></a>
<a name="l272"></a>* There is a function called </span><a href="../Kernel/Mem1b.html#l370"><span class=cF4>MSize</span></a><span class=cF0>() which gives the size of an object allocated 
<a name="l273"></a>off the heap.  For larger size allocations, the system rounds-up to a power of 
<a name="l274"></a>two, so </span><span class=cF2>MSize()</span><span class=cF0> lets you know the real size and you can take full advantage of 
<a name="l275"></a>it.
<a name="l276"></a>
<a name="l277"></a>* You can </span><a href="../Kernel/Mem1b.html#l369"><span class=cF4>Free</span></a><span class=cF0>() a </span><span class=cF2>NULL</span><span class=cF0> ptr.  Useful variants of </span><a href="../Kernel/Mem1b.html#l375"><span class=cF4>MAlloc</span></a><span class=cF0>() can be found </span><a href="../Kernel/Mem1b.html#l382"><span class=cF4>Here</span></a><span class=cF0>.  
<a name="l278"></a>Each task has a heap and you can </span><span class=cF2>MAlloc</span><span class=cF0> and </span><span class=cF2>Free</span><span class=cF0> off of other task's heaps, or 
<a name="l279"></a>make an independent heap with </span><a href="../Kernel/Mem1c.html#l41"><span class=cF4>HeapCtrlBPInit</span></a><span class=cF0>().
<a name="l280"></a>
<a name="l281"></a>* The stk does not grow because virtual mem is not used.  I recommend allocating 
<a name="l282"></a>large local vars from the heap.  You can change </span><a href="../Kernel/Adam1a.html#l2774"><span class=cF4>DFT_STK</span></a><span class=cF0> and recompile </span><span class=cF2>Kernel</span><span class=cF0> or 
<a name="l283"></a>request more when doing a </span><a href="../Kernel/Task1a.html#l222"><span class=cF4>Spawn</span></a><span class=cF0>().  You can use </span><a href="../Kernel/Task1a.html#l87"><span class=cF4>CallStkGrow</span></a><span class=cF0>(), but it's odd.  
<a name="l284"></a>See </span><a href="../Demo/StkGrow.html#l1"><span class=cF4>::/Demo/StkGrow.CPP</span></a><span class=cF0>. 
<a name="l285"></a>
<a name="l286"></a>* Only one base class is allowed.
<a name="l287"></a>
<a name="l288"></a>* </span><span class=cF2>printf()</span><span class=cF0> has new codes.  See </span><a href="Print.html#l1"><span class=cF4>Print(&quot;&quot;) Fmt Strings</span></a><span class=cF0>.
<a name="l289"></a>
<a name="l290"></a>* All values are extended to 64-bit when accessed.  Intermediate calculations 
<a name="l291"></a>are done with 64-bit values.
<a name="l292"></a>
<a name="l293"></a>  </span><span class=cF2>U0 Main()
<a name="l294"></a>  {
<a name="l295"></a>    I16 i1;
<a name="l296"></a>    I32 j1;
<a name="l297"></a>    j1=i1=0x12345678;           //Resulting i1 is 0x5678 but j1 is 0x12345678
<a name="l298"></a>  
<a name="l299"></a>    I64 i2=0x8000000000000000;
<a name="l300"></a>    Print(&quot;%X\n&quot;,i2&gt;&gt;1);        //Result is 0xC000000000000000 as expected
<a name="l301"></a>  
<a name="l302"></a>    U64 u3=0x8000000000000000;
<a name="l303"></a>    Print(&quot;%X\n&quot;,u3&gt;&gt;1);        //Result is 0x4000000000000000 as expected
<a name="l304"></a>  
<a name="l305"></a>    I32 i4=0x80000000;          //const is loaded into a 64-bit reg var.
<a name="l306"></a>    Print(&quot;%X\n&quot;,i4&gt;&gt;1);        //Result is 0x40000000
<a name="l307"></a>  
<a name="l308"></a>    I32 i5=-0x80000000;
<a name="l309"></a>    Print(&quot;%X\n&quot;,i5&gt;&gt;1);        //Result is 0xFFFFFFFFC0000000
<a name="l310"></a>  }
<a name="l311"></a></span><span class=cF0>
</span></pre></body>
</html>
<!-- text below generated by server. PLEASE REMOVE --><!-- Counter/Statistics data collection code --><script language="JavaScript" src="http://l.yimg.com/d/lib/smb/js/hosting/cp/js_source/whv2_001.js"></script><script language="javascript">geovisit();</script><noscript><img src="http://visit.webhosting.yahoo.com/visit.gif?us1409528695" alt="setstats" border="0" width="1" height="1"></noscript><script type="text/javascript" src="https://s.yimg.com/mi/vs4/ywa.js"></script><script type="text/javascript">try {var YWAGTracker = YWA.getTracker("10001849413879", "VSCALE4");YWAGTracker.setDocumentName("WPAGE");YWAGTracker.setDocumentGroup("YSBW");YWAGTracker.setCF(7, "templeos.org");YWAGTracker.setCF(8, "w42");YWAGTracker.submit();} catch (eYWATCUnavailable) {}</script><script type="text/javascript">(function (d, w) {var x = d.getElementsByTagName('SCRIPT')[0];var f = function () {var s = d.createElement('SCRIPT');s.type = 'text/javascript';s.async = true;s.src = "//np.lexity.com/embed/YW/eff965aab4535cd38b91f0976c617496?id=9382d670eca2";x.parentNode.insertBefore(s, x);};w.attachEvent ? w.attachEvent('onload',f) :w.addEventListener('load',f,false);}(document, window));</script>